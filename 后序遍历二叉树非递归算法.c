//后序遍历二叉树非递归算法
//此算法真的精妙，第一次看不懂，画出一个真实用例树才证明出算法的正确性
void PostOrder(BitTree T){
	//初始化栈
	InitStack(s);
	//初始化工作指针
	p=T;
	//初始化存储访问过节点的指针
	r=NULL;
	//当p有所指或栈中有货时，迭代
	while(p||!IsEmpty(s)){
		//p有所指，先走到最左边
		if(p){
			//边压栈边往左走
			push(S,p);
			p=p->lchild; 
		} else{
			//p空了，说明已经弹出访问过一个节点，此时取栈顶节点一定是访问节点的父节点
			GetTop(S,p);
			//如果这个小父亲有右子树，则顺势访问右边，满足后序遍历 
			if(p->rchild&&p->rchild!=r){//判断访问过没有，访问过再回到这里就跳过，说明左右都走过，直接访问根节点 
				p=p->rchild;
				push(S,p);
				//别忘了即便在右子树也要往左走，从右子树的最左边开始访问，满足后序遍历 
				p=p->lchild;
			} else{
				//父节点没有右子树或者右子树访问过了，则走到这里，就剩父节点自己啦~~
				//凡是访问的节点都弹出，栈中都是没访问过的 
				pop(S,p);
				visit(p->data);
				//访问过的还要记录 
				r=p;
				//访问过要把p置空，下次就get栈顶节点，访问父亲了 
				p=NULL; 
			}
		}
	} 
} 
