//在二叉树中查找并打印值等于x的节点所有祖先 
//本题设计一个常用寻找祖先思路：非递归后序遍历，此种方法访问到x时，栈中刚好是所有祖先 

typedef struct{//建站保存树和标识，标识0表示左孩子被访问，1表示右孩子被访问 
	BiTree t;
	int tag;
}stack;
void Ancestor(BiTree b,ElemType x){
	//初始化栈和指针
	stack s[];
	p=0;
	//当树不为空（有左右孩子）或者树为空栈不为空时，迭代
	while(b!=NULL || p>0){
		//树没空并且没找到x就一直压栈左子树 
		while(b!=NULL && b->data!=x){
			s[++p].t=b;
			s[p].tag=0;
			b=b->lchild;
		} 
		//一旦走狗屎运找到x，循环输出栈中元素直接结束
		if(b->data==x){
			for(i=1;i<=p;i++){
				printf("%d",s[i].t->data);
			}
			exit(1);
		} 
		//这行可以先不看，因为这里条件一开始是不满足的，先执行的下个if，下个if完了才到这里
		//当下一个if的右边孩子也走到底了且走不到左边，退栈，从更早的父节点往右走 
		if(p!=0&&s[p].tag==1){
			p--;
		} 
		//好了，此时此刻，此时此刻，左边走到头了，该走右边了
		if(p!=0){//树空了，栈不为空，就往右走咯 
			//设置标识为1
			s[p].tag=1;
			//注意，这里不是树最底下节点往右边了，因为树到底了，是栈顶节点，也就是最底下节点的爸往右边，因此这里是退了一格的 
			b=s[p].t->rchild;
			//这里走完了回到while开始，即从这个右分叉点再向左遍历到底 
		} 
	}
}
